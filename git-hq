#!/usr/bin/env python
import sys,os
try:
    import configparser as cp
except:
    import ConfigParser as cp   # python 2.x
#sys.path.insert(0,os.getcwd())
import git

program_name = "git-hq"
config_path = os.getenv("HOME")+"/."+program_name

class Repo(object):
    def __init__(self,name,id,repos):
        self.name = name
        self.id = id
        self.repos = repos

class CmdFailed(Exception):
    def __init__(self,cmd,reason=None):
        self.cmd = cmd
        if not reason is None: self.reason = reason
    def __str__(self):
        return repr(self.cmd)
    def message(self):
        print(program_name+": "+self.cmd+" command failed")
        if hasattr(self,'reason'): print(self.reason)

class NoRepo(Exception):
    def message(self,exists):
        if exists:
            print(program_name+": git repository not in config file")
            suggest()
        else:
            print(program_name+": no repository found or not in config file")
    

class NoDesiredRepo(Exception):
    def message(self,exists):
        if exists:
            print(program_name+": git repository currently exists here")
        else:
            print(program_name+": repository not in config file")

def load_config(file):
    c = cp.RawConfigParser()
    c.read(file)

    remotes = dict(c.items('remotes'))
    del remotes['uname']

    sections = c.sections()
    sections.remove('remotes')
    
    repos = {}

    for s in sections:
        p = dict(c.items(s))    # p=properties
        try:
            remote = [(r,remotes[r].replace("{repo}",s).replace("{uname}",p['uname']))
                      for r in p['repos'].split(',')]
        except KeyError:
            remote = []
        repos[p['id']] = Repo(s,p['id'],remote)
    return repos,remotes

def ammend_config(file,section,data):
    c = cp.RawConfigParser()
    c.read(file)
    c.set(section,data[0],data[1])
    with open(file, 'wb') as f:
        c.write(f)

def identify_current_repo(repos):
    for h in git.hashes():
        if(h in repos):
            return repos[h]
    return None

def identify_desired_repo(repos,name):
    try:
        return next(r for k,r in repos.items() if r.name==name)
    except StopIteration:
        return None

def suggest():
    try:
        print("""Add the following to ~/.%s to include this repo
[%s]
id=%s
repos=...""" % (program_name, git.name(), git.last_hash()) )
    except:
        print("""Add repo information to ~/.%s or run in existing repository""" %
              program_name)

def cmd_help(args=None):
    print("""usage: %s <command>
commands available include:
\tbootstrap
\tclone
\tpull
\tpush
\thelp""" % program_name)

def valid_argument(arg,err):
    if arg is None:
        raise err

def remote(args):

    def sub_add(subargs):
        if len(subargs) < 2: raise CmdFailed('remote add',"too few arguments")
        ammend_config(config_path,'remotes',(subargs[0],subargs[1]))

    def sub_attach(subargs):
        if len(subargs) < 1: raise CmdFailed('remote attach',"too few arguments")
        valid_argument(args['repo'],NoRepo)
        if not subargs[0] in args['remotes']: raise CmdFailed('remote attach',"remote not in config file")
        if subargs[0] in [r[0] for r in args['repo'].repos]: raise CmdFailed('remote attach',"remote already attached")
        ammend_config(config_path,
                      args['repo'].name,
                      ('repos',
                       ','.join([r[0] for r in args['repo'].repos]+[subargs[0]])))

    def sub_detach(subargs):
        if len(subargs) < 1: raise CmdFailed('remote detach',"too few arguments")
        valid_argument(args['repo'],NoRepo)
        if not subargs[0] in [r[0] for r in args['repo'].repos]: raise CmdFailed('remote detach',"remote not attached")
        ammend_config(config_path,
                      args['repo'].name,
                      ('repos',
                       ','.join([r[0] for r in filter(lambda r: r[0]!=subargs[0],args['repo'].repos)])))

    subcmd = {'add':sub_add, 'attach':sub_attach, 'detach':sub_detach}
    param = args['argv'] 
    if not param:
        remotes = args['remotes']
        for r in remotes:
            print(r+" "+remotes[r])
    elif not param[0] in subcmd:
        raise CmdFailed('remote')
    else:
        subcmd[param[0]](param[1:])

def bootstrap(args):
    valid_argument(args['repo'],NoRepo)
    for name,url in args['repo'].repos:
        print(program_name+": Adding "+name+" remote")
        git.cmd(['remote','add',name,url])

def clone(args):
    valid_argument(args['desired'],NoDesiredRepo)
    git.cmd(['clone',args['desired'].repos[0][1]]+list(args['argv']))

def pull(args):
    valid_argument(args['repo'],NoRepo)
    if not args['repo'].repos: raise CmdFailed('pull',"no repos to pull from")
    git.cmd(['pull',args['repo'].repos[0][1]]+list(args['argv']))

def push(args):
    valid_argument(args['repo'],NoRepo)
    if not args['repo'].repos: raise CmdFailed('push',"no repos to push from")
    for name,url in args['repo'].repos:
        git.cmd(['push',url]+list(args['argv']))

def main(*argv):

    if (len(argv) < 2):
        cmd_help()
        return 0

    try:
        repos,remotes = load_config(config_path)
    except IOError:
        print("fatal: no ~/."+program_name+" config file found")
        return 1

    # check if we can even get repo info...
    exists = git.exists()
    # obtain repo info if so
    repo = identify_current_repo(repos) if exists else None
    # if user was trying to create a repo, look it up in config
    desired_repo = (identify_desired_repo(repos,argv[2]) if 
                    (len(argv) > 2) else None)

    arguments = {'exists':exists, 'repo':repo, 'desired':desired_repo, 'remotes':remotes, 'argv':argv[2:]}

    verbs = {'bootstrap':bootstrap, 'clone':clone, 'pull':pull, 'push':push, 'remote':remote, 'help':cmd_help}

    try:
        verbs[argv[1]](arguments)
    except KeyError:
        print(program_name+": "+argv[1]+" is not a "+program_name+" command. See 'git hq help'.")
        return 1
    except (NoRepo,NoDesiredRepo) as e:
        e.message(exists)
        return 1
    except CmdFailed as e:
        e.message()
    except:
        print(program_name+": git command failed")
        return 1

    return 0
 
if __name__ == '__main__':
    sys.exit(main(*sys.argv))
